<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monochrome Deco - Final Cityscape</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 30, 95); 

        // --- WINDOW TEXTURE GENERATOR ---
        function createStochasticTexture() {
            const canvas = document.createElement('canvas');
            const res = 512; canvas.width = res; canvas.height = res;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, res, res);
            const grid = 12; const padding = 8;
            const winSize = (res - (padding * (grid + 1))) / grid;
            const threshold = 0.4 + Math.random() * 0.35; 
            for(let y=0; y<grid; y++) {
                for(let x=0; x<grid; x++) {
                    if (Math.random() < threshold) {
                        const b = 120 + Math.floor(Math.random() * 80);
                        ctx.fillStyle = `rgb(${b},${b},${b})`;
                        ctx.fillRect(padding + x*(winSize+padding), padding + y*(winSize+padding), winSize, winSize);
                    }
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- FIXED CAMERA (Fixes black triangle clipping) ---
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 26; 
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, 
            frustumSize * aspect / 2, 
            frustumSize / 2, 
            frustumSize / -2, 
            -100, // Near plane moved back to prevent clipping
            1000  // Far plane
        );
        camera.position.set(40, 25, 40); 
        camera.lookAt(0, -2, 0); 

        const sun = new THREE.DirectionalLight(0xffffff, 1.1);
        sun.position.set(20, 50, 15);
        scene.add(sun);
        const fill = new THREE.DirectionalLight(0xffffff, 0.35);
        fill.position.set(-20, 10, -20);
        scene.add(fill);

        // --- MATERIALS ---
        const sideMat = new THREE.MeshStandardMaterial({ color: 0x040404, roughness: 0.5 });
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 1.0 });
        const boxMaterials = [sideMat, sideMat, roofMat, roofMat, sideMat, sideMat]; 
        
        const towers = [];
        const beaconMaterials = []; 
        const loopX = 140; 
        const loopZ = 100;

        // --- TOWER GENERATOR ---
        function createTower(x, z) {
            const tower = new THREE.Group();
            const tex = createStochasticTexture();
            const isHero = Math.random() > 0.92; 
            
            const floors = (isHero ? 45 : 8) + Math.random() * 30;
            const targetHeight = floors * (1/3.5); 
            
            let w = (isHero ? 5.5 : 3.8) + Math.random() * 3.5;
            let d = (isHero ? 5.5 : 3.8) + Math.random() * 3.5;
            let currentY = 0, prevW = w, prevD = d;

            while (currentY < targetHeight) {
                const shrink = 0.12 + Math.random() * 0.1;
                let cw = Math.max(1.2, prevW * (1 - shrink));
                let cd = Math.max(1.2, prevD * (1 - shrink));
                let ch = 1.4 + Math.random() * 2.2; 

                const core = new THREE.Mesh(new THREE.BoxGeometry(cw, ch, cd), boxMaterials);
                core.position.y = currentY + ch/2;
                tower.add(core);

                if (isHero && cw > 2.5) {
                    const fin = new THREE.Mesh(new THREE.BoxGeometry(0.15, ch, cd + 0.2), roofMat);
                    fin.position.y = currentY + ch/2;
                    tower.add(fin);
                }

                const winMat = new THREE.MeshStandardMaterial({ 
                    map: tex, emissiveMap: tex, emissive: 0xffffff, emissiveIntensity: 0.4 
                });
                winMat.map.repeat.set(cw * 0.5, ch * 0.5);
                winMat.map.offset.set(Math.random(), Math.random());

                const createSide = (sw, sh, px, pz, ry) => {
                    const p = new THREE.Mesh(new THREE.PlaneGeometry(sw - 0.12, sh - 0.12), winMat);
                    p.position.set(px, currentY + ch/2, pz);
                    p.rotation.y = ry;
                    tower.add(p);
                };

                createSide(cw, ch, 0, cd/2 + 0.01, 0);
                createSide(cw, ch, 0, -cd/2 - 0.01, Math.PI);
                createSide(cd, ch, cw/2 + 0.01, 0, Math.PI/2);
                createSide(cd, ch, -cw/2 - 0.01, 0, -Math.PI/2);

                currentY += ch; prevW = cw; prevD = cd;
            }

            if (isHero) {
                const spireH = 4 + Math.random() * 6;
                const spire = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.3, spireH, 4), roofMat);
                spire.position.y = currentY + spireH/2;
                tower.add(spire);

                const beaconMat = new THREE.MeshBasicMaterial({ color: 0xff1111, transparent: true });
                beaconMat.userData = { 
                    phaseOffset: Math.random() * Math.PI * 2,
                    speed: 1.5 + Math.random() * 3 
                };

                const beacon = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8), beaconMat);
                beacon.position.y = currentY + spireH;
                tower.add(beacon);
                beaconMaterials.push(beaconMat);
            }

            tower.position.set(x, 0, z);
            return tower;
        }

        // --- INITIALIZATION ---
        const rows = 16; 
        const cols = 22;
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const x = (c / cols - 0.5) * loopX + (Math.random() - 0.5) * 4;
                const z = (r / rows - 0.5) * loopZ + (Math.random() - 0.5) * 4;
                const t = createTower(x, z);
                towers.push(t); scene.add(t);
            }
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            // Pulse beacons asynchronously
            beaconMaterials.forEach(m => {
                const s = m.userData;
                m.opacity = 0.3 + Math.pow(Math.sin(elapsedTime * s.speed + s.phaseOffset) * 0.5 + 0.5, 3.0);
            });

            towers.forEach(t => {
                t.position.x -= 0.05;
                if (t.position.x < -loopX/2) t.position.x += loopX;
            });
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
